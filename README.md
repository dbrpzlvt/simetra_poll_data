# EDA анализ

## Очистка данных
Были обнаружены два одинаковых столбца ~"В каком районе находится место Вашей учебы/ работы?" (индексы 14 и 15)
Объединяю данные столбцы и удаляю лишние

DataFrame был разделен на логические блоки опроса:
разделение дополнительных ответов по перемещениям на блоки - датафреймы

general_info = df.iloc[:, :37] # основная информация (основные данные опроса)
first_moving = df.iloc[:, 37:list_col_index[0]] # данные опроса про первое из последних совершенных перемещений
second_moving = df.iloc[:, list_col_index[0]:list_col_index[1]] # -//-
third_moving = df.iloc[:, list_col_index[1]:list_col_index[2]] # -//-
fourth_moving = df.iloc[:, list_col_index[2]:list_col_index[3]] # -//-
fifth_moving = df.iloc[:, list_col_index[3]:list_col_index[4]] # -//-
sixth_moving = df.iloc[:, list_col_index[4]:-15] # -//-
additional_info = df.iloc[:, -15:] # дополнительная информация в опрос-листе

## Проведены дополнительные предобработки данных: 
1) замена значений из столбца AW -> AV; и замена значений в столбце AP (нет -> да). (видимо, пользователи неправильно указали в столбце AP место отправления)
2) обработка данных о времени в первом перемещении (часы:минуты) отправления/прибытия в first_moving (индексы 5 и 6 - часы отправления/прибытия, индексы 7 и 8 - минуты отправления/прибытия):
- если часы отправления/прибытия введены как 24, то такие значения заменяются на 0
- если время отправления (соединенные столбцы часы и минуты) оказалось больше/позже времени прибытия (соединенные соответствующие столбцы) – видимо, пользователи неправильно указали значения времени в опросе, – то такие времена считаются одинаковыми, чтобы разница между ними составила 00ч:00м
3) то же самое для второго перемещения

## Далее составляем краткое ревью об основном блоке опроса:

general_info.describe()

print('\033[1m'+ 'Уникальные значения'+'\033[0m'+'\n')
for i in general_info.columns.to_list():
    print('\033[91m'+ 'Признак "{}" имеет \033[1m\033[91m {} \033[0m\033[91m следующих уникальных значений:'.format(i, len(general_info[i].unique()))+'\033[0m')
    print(general_info[i].unique())
    print('Индекс столбца ', general_info.columns.get_loc(i))
    print('\033[1m' + '---------------------------------------------------------------------------------'+ '\033[0m')

Удаляем лишние столбцы, либо не имеющие никакой полезной информации (все значения NaN), либо имеющие «мусор»
Получили DataFrame размером shape of data is (1000, 31)
